<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>久智数字人-控制台</title>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
    body {
        font-family: 'Noto Sans SC', sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f5f5f7;
        color: #333;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
    }
    
    .container {
        max-width: 800px;
        margin: 0 auto;
        padding: 20px;
        flex: 1;
        display: flex;
        flex-direction: column;
        justify-content: center;
    }
    
    .card {
        background-color: white;
        border-radius: 12px;
        box-shadow: 0 4px 20px rgba(0,0,0,0.08);
        padding: 25px;
        margin-bottom: 20px;
        transition: all 0.3s ease;
    }
    
    .card:hover {
        box-shadow: 0 8px 30px rgba(0,0,0,0.12);
        transform: translateY(-2px);
    }
    
    .card-header {
        display: flex;
        align-items: center;
        justify-content: space-between;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 1px solid #eee;
    }
    
    .card-title {
        font-size: 18px;
        font-weight: 600;
        margin: 0;
        color: #333;
        display: flex;
        align-items: center;
    }
    
    .card-title::before {
        content: "";
        display: inline-block;
        width: 4px;
        height: 18px;
        background: linear-gradient(to bottom, #4CAF50, #2196F3);
        margin-right: 10px;
        border-radius: 2px;
    }
    
    .form-group {
        display: flex;
        flex-direction: column;
        margin-bottom: 15px;
    }
    
    .form-label {
        font-size: 14px;
        margin-bottom: 8px;
        color: #666;
        font-weight: 500;
    }
    
    input[type="text"], 
    input[type="number"],
    textarea {
        padding: 12px 15px;
        border: 1px solid #ddd;
        border-radius: 8px;
        font-size: 14px;
        transition: all 0.2s;
        background-color: #f9f9f9;
    }
    
    input[type="text"]:focus,
    input[type="number"]:focus,
    textarea:focus {
        outline: none;
        border-color: #2196F3;
        box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        background-color: white;
    }
    
    textarea {
        min-height: 120px;
        resize: vertical;
    }
    
    .button-row {
        display: flex;
        gap: 10px;
        margin-top: 10px;
    }
    
    button {
        padding: 12px 20px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        color: white;
        font-weight: 500;
        font-size: 14px;
        transition: all 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
    }
    
    button:active {
        transform: translateY(0);
    }
    
    #send-btn {
        background: linear-gradient(135deg, #2196F3, #0D47A1);
        flex: 1;
    }
    
    #connect-ws-btn {
        background: linear-gradient(135deg, #4CAF50, #2E7D32);
    }
    
    #disconnect-ws-btn {
        background: linear-gradient(135deg, #F44336, #B71C1C);
    }
    
    .config-row {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-bottom: 15px;
    }
    
    .config-item {
        flex: 1;
        min-width: 200px;
    }
    
    /* 键盘快捷键提示 */
    .keyboard-hint {
        display: block;
        text-align: right;
        font-size: 12px;
        color: #999;
        margin-top: 5px;
    }
    
    /* 发送状态提示 */
    .send-status {
        display: flex;
        align-items: center;
        margin-top: 15px;
        font-size: 14px;
        color: #666;
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    .send-status.visible {
        opacity: 1;
    }
    
    .send-status-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-right: 8px;
    }
    
    .send-status-icon.success {
        background-color: #4CAF50;
    }
    
    .send-status-icon.error {
        background-color: #F44336;
    }
    
    /* 弹幕区域样式 */
    .danmaku-container {
        margin-top: 20px;
        border: 1px solid #eee;
        border-radius: 8px;
        height: 300px;
        overflow-y: auto;
        padding: 15px;
        background-color: #f9f9f9;
    }
    
    .danmaku-item {
        padding: 8px 12px;
        margin-bottom: 8px;
        border-radius: 6px;
        background-color: white;
        box-shadow: 0 1px 3px rgba(0,0,0,0.05);
        animation: fadeIn 0.3s ease;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
    
    .danmaku-user {
        font-weight: 500;
        color: #2196F3;
        margin-right: 8px;
    }
    
    .danmaku-time {
        font-size: 12px;
        color: #999;
        float: right;
    }
    
    .danmaku-content {
        margin-top: 5px;
        word-break: break-all;
    }
    
    .ws-status {
        display: inline-flex;
        align-items: center;
        font-size: 14px;
        margin-left: 10px;
    }
    
    .ws-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 5px;
    }
    
    .ws-indicator.connected {
        background-color: #4CAF50;
        box-shadow: 0 0 5px #4CAF50;
    }
    
    .ws-indicator.disconnected {
        background-color: #F44336;
    }
    
    .ws-indicator.connecting {
        background-color: #FF9800;
        animation: blink 1s infinite;
    }
    
    @keyframes blink {
        50% { opacity: 0.5; }
    }
    
    /* 响应式设计 */
    @media (max-width: 768px) {
        .container {
            padding: 15px;
        }
        
        .card {
            padding: 20px 15px;
        }
        
        .button-row {
            flex-direction: column;
        }
        
        button {
            width: 100%;
        }
        
        .danmaku-container {
            height: 200px;
        }
    }
    
    /* 超宽屏适配 */
    @media (min-width: 1600px) {
        .container {
            max-width: 1000px;
        }
        
        .card {
            padding: 30px;
        }
        
        textarea {
            min-height: 150px;
        }
        
        .danmaku-container {
            height: 400px;
        }
    }
    
    /* 弹幕头像样式 */
    .danmaku-avatar {
        width: 24px;
        height: 24px;
        border-radius: 50%;
        margin-right: 8px;
        object-fit: cover;
    }
    
    .danmaku-header {
        display: flex;
        align-items: center;
        margin-bottom: 5px;
    }
    
    /* 不同类型弹幕的样式 */
    .danmaku-item.enter {
        background-color: rgba(76, 175, 80, 0.1);
        border-left: 3px solid #4CAF50;
    }
    
    .danmaku-item.follow {
        background-color: rgba(233, 30, 99, 0.1);
        border-left: 3px solid #E91E63;
    }
    
    .danmaku-item.system {
        background-color: rgba(33, 150, 243, 0.1);
        border-left: 3px solid #2196F3;
    }
    
    .danmaku-item.normal {
        background-color: white;
    }
    
    .danmaku-system-icon {
        width: 16px;
        height: 16px;
        border-radius: 50%;
        background-color: #2196F3;
        margin-right: 8px;
        display: inline-block;
    }
    
    .danmaku-system-label {
        color: #2196F3;
        font-weight: 500;
    }
    
    /* 添加自动回复相关样式 */
    .auto-reply-card {
        background-color: #f8f9ff;
        border-left: 4px solid #5c6bc0;
    }
    
    .auto-reply-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
    }
    
    .auto-reply-toggle {
        display: flex;
        align-items: center;
    }
    
    .toggle-switch {
        position: relative;
        display: inline-block;
        width: 50px;
        height: 24px;
        margin-left: 10px;
    }
    
    .toggle-switch input {
        opacity: 0;
        width: 0;
        height: 0;
    }
    
    .toggle-slider {
        position: absolute;
        cursor: pointer;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #ccc;
        transition: .4s;
        border-radius: 24px;
    }
    
    .toggle-slider:before {
        position: absolute;
        content: "";
        height: 18px;
        width: 18px;
        left: 3px;
        bottom: 3px;
        background-color: white;
        transition: .4s;
        border-radius: 50%;
    }
    
    input:checked + .toggle-slider {
        background-color: #5c6bc0;
    }
    
    input:checked + .toggle-slider:before {
        transform: translateX(26px);
    }
    
    .model-config {
        display: flex;
        flex-wrap: wrap;
        gap: 15px;
        margin-top: 15px;
    }
    
    .model-config-item {
        flex: 1;
        min-width: 200px;
    }
    
    .provider-select {
        padding: 10px;
        border-radius: 8px;
        border: 1px solid #ddd;
        background-color: white;
        width: 100%;
    }
    
    .auto-reply-status {
        display: flex;
        align-items: center;
        margin-top: 15px;
        padding: 10px;
        border-radius: 8px;
        background-color: rgba(92, 107, 192, 0.1);
    }
    
    .auto-reply-status.active {
        background-color: rgba(76, 175, 80, 0.1);
    }
    
    .auto-reply-status.error {
        background-color: rgba(244, 67, 54, 0.1);
    }
    
    .auto-reply-indicator {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        margin-right: 10px;
    }
    
    .auto-reply-indicator.active {
        background-color: #4CAF50;
        box-shadow: 0 0 5px #4CAF50;
    }
    
    .auto-reply-indicator.inactive {
        background-color: #9E9E9E;
    }
    
    .auto-reply-indicator.error {
        background-color: #F44336;
    }
    
    /* 不同类型回复的样式 */
    .reply-message {
        background-color: rgba(92, 107, 192, 0.1);
        border-left: 3px solid #5c6bc0;
    }
    
    .reply-message.reply-enter {
        background-color: rgba(76, 175, 80, 0.05);
        border-left: 3px solid #4CAF50;
    }
    
    .reply-message.reply-follow {
        background-color: rgba(233, 30, 99, 0.05);
        border-left: 3px solid #E91E63;
    }
    
    .reply-message.reply-system {
        background-color: rgba(33, 150, 243, 0.05);
        border-left: 3px solid #2196F3;
    }
    
    .reply-user {
        color: #5c6bc0;
    }
    
    .reply-icon-enter, .reply-icon-follow, .reply-icon-system {
        display: inline-block;
        width: 16px;
        height: 16px;
        border-radius: 50%;
        margin-right: 8px;
    }
    
    .reply-icon-enter {
        background-color: #4CAF50;
    }
    
    .reply-icon-follow {
        background-color: #E91E63;
    }
    
    .reply-icon-system {
        background-color: #2196F3;
    }
    
    /* 隐藏元素 */
    .hidden {
        display: none !important;
    }
    
    /* 阿里云配置样式 */
    #aliyun-config {
        background-color: rgba(255, 106, 0, 0.03);
        padding: 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 106, 0, 0.1);
    }
    
    /* 添加流类型选择器样式 */
    .stream-type-selector {
        display: flex;
        background-color: rgba(0, 0, 0, 0.05);
        border-radius: 8px;
        overflow: hidden;
    }
    
    .stream-type-option {
        padding: 8px 16px;
        cursor: pointer;
        transition: all 0.2s;
        font-size: 14px;
    }
    
    .stream-type-option.active {
        background-color: #2196F3;
        color: white;
        font-weight: 500;
    }
    
    .stream-type-option:hover:not(.active) {
        background-color: rgba(0, 0, 0, 0.05);
    }
    </style>
</head>
<body>

<div class="container">
    <div class="card">
        <div class="card-header">
            <h2 class="card-title">数字人控制台</h2>
            <div class="stream-type-selector">
                <div class="stream-type-option active" id="webrtc-option" onclick="javascript:window.selectStreamType('webrtc');return false;">WebRTC</div>
                <div class="stream-type-option" id="srs-option" onclick="javascript:window.selectStreamType('srs');return false;">SRS流</div>
            </div>
        </div>
        
        <div class="config-row">
            <div class="config-item">
                <div class="form-group">
                    <label for="server-url-input" class="form-label">数字人源地址</label>
                    <input id="server-url-input" type="text" placeholder="请输入服务器地址 (例如: http://192.168.1.100:8080)" />
                </div>
            </div>
            <div class="config-item">
                <div class="form-group">
                    <label for="session-id-input" class="form-label">连接码</label>
                    <input id="session-id-input" type="number" min="0" placeholder="输入连接码" />
                </div>
            </div>
        </div>
        
        <div class="form-group">
            <label for="message" class="form-label">输入文字</label>
            <textarea id="message" placeholder="输入任意文字让数字人开口说话"></textarea>
            <span class="keyboard-hint">快捷键: Ctrl + Enter 发送</span>
        </div>
        
        <div class="button-row">
            <button id="send-btn">发送</button>
        </div>
        
        <div class="send-status" id="send-status">
            <div class="send-status-icon" id="status-icon"></div>
            <span id="status-text">发送成功</span>
        </div>
    </div>
    
    <div class="card">
        <div class="card-header">
            <h2 class="card-title">弹幕监听</h2>
        </div>
        
        <div class="form-group">
            <label for="ws-url-input" class="form-label">WebSocket地址</label>
            <input id="ws-url-input" type="text" placeholder="输入WebSocket地址 (例如: ws://0.0.0.0:8888)" />
        </div>
        
        <div class="button-row">
            <button id="connect-ws-btn">连接</button>
            <button id="disconnect-ws-btn" disabled style="background: linear-gradient(135deg, #F44336, #B71C1C);">断开</button>
            <div class="ws-status">
                <span class="ws-indicator disconnected" id="ws-indicator"></span>
                <span id="ws-status-text">未连接</span>
            </div>
        </div>
        
        <div class="danmaku-container" id="danmaku-container">
            <!-- 弹幕内容将在这里显示 -->
        </div>
    </div>
    
    <!-- 新增大模型自动回复卡片 -->
    <div class="card auto-reply-card">
        <div class="card-header auto-reply-header">
            <h2 class="card-title">大模型自动回复</h2>
            <div class="auto-reply-toggle">
                <span>启用</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="auto-reply-toggle">
                    <span class="toggle-slider"></span>
                </label>
            </div>
        </div>
        
        <div class="form-group">
            <label for="provider-select" class="form-label">服务提供商</label>
            <select id="provider-select" class="provider-select">
                <option value="openai">OpenAI 兼容接口</option>
                <option value="aliyun">阿里云百炼</option>
            </select>
        </div>
        
        <div class="model-config" id="openai-config">
            <div class="model-config-item">
                <div class="form-group">
                    <label for="api-base-url" class="form-label">API 基础地址</label>
                    <input id="api-base-url" type="text" placeholder="例如: https://api.openai.com/v1" />
                </div>
            </div>
            <div class="model-config-item">
                <div class="form-group">
                    <label for="api-key" class="form-label">API Key</label>
                    <input id="api-key" type="password" placeholder="输入您的API密钥" />
                </div>
            </div>
            <div class="model-config-item">
                <div class="form-group">
                    <label for="model-name" class="form-label">模型名称</label>
                    <input id="model-name" type="text" placeholder="例如: gpt-3.5-turbo" />
                </div>
            </div>
        </div>
        
        <div class="model-config hidden" id="aliyun-config">
            <div class="model-config-item">
                <div class="form-group">
                    <label for="aliyun-api-key" class="form-label">API Key</label>
                    <input id="aliyun-api-key" type="password" placeholder="输入您的阿里云API密钥" />
                </div>
            </div>
            <div class="model-config-item">
                <div class="form-group">
                    <label for="aliyun-app-id" class="form-label">应用ID (App ID)</label>
                    <input id="aliyun-app-id" type="text" placeholder="输入您的应用ID" />
                </div>
            </div>
        </div>
        
        <div class="form-group">
            <label for="system-prompt" class="form-label">系统提示词</label>
            <textarea id="system-prompt" placeholder="设置AI的行为和角色">你是一个友好的直播助手，负责回答观众的问题。请保持回答简洁、友好。</textarea>
        </div>
        
        <div class="auto-reply-status" id="auto-reply-status">
            <div class="auto-reply-indicator inactive" id="auto-reply-indicator"></div>
            <span id="auto-reply-status-text">自动回复未启用</span>
        </div>
    </div>
</div>

<script type="text/javascript" src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script type="text/javascript">
// 全局定义selectStreamType函数
window.selectStreamType = function(type) {
    console.log('切换流类型到:', type);
    
    // 保存当前选择的流类型
    window.streamType = type;
    
    // 更新UI
    $('#webrtc-option').toggleClass('active', type === 'webrtc');
    $('#srs-option').toggleClass('active', type === 'srs');
    
    // 显示/隐藏连接码字段
    if (type === 'webrtc') {
        $('.config-item:nth-child(2)').show();
        $('#server-url-input').attr('placeholder', '请输入服务器地址 (例如: http://192.168.1.100:8080)');
        
        // 恢复WebRTC模式下的服务器地址
        const savedWebrtcUrl = localStorage.getItem('webrtcServerUrl');
        if (savedWebrtcUrl) {
            $('#server-url-input').val(savedWebrtcUrl);
        }
    } else {
        $('.config-item:nth-child(2)').hide();
        $('#server-url-input').attr('placeholder', '请输入SRS流地址或服务器IP (例如: 114.55.116.94 或 webrtc://server/live/stream)');
        
        // 恢复SRS模式下的服务器地址
        const savedSrsUrl = localStorage.getItem('srsServerUrl');
        if (savedSrsUrl) {
            $('#server-url-input').val(savedSrsUrl);
        }
    }
    
    // 如果jQuery已加载，保存设置
    if (typeof $ !== 'undefined') {
        localStorage.setItem('streamType', type);
    }
};

$(document).ready(function() {
    // 获取保存的设置
    let serverUrl = localStorage.getItem('serverUrl') || '';
    let sessionId = localStorage.getItem('sessionId') || '0';
    let wsUrl = localStorage.getItem('wsUrl') || '';
    let streamType = localStorage.getItem('streamType') || 'webrtc';
    
    // 大模型设置
    let apiBaseUrl = localStorage.getItem('apiBaseUrl') || '';
    let apiKey = localStorage.getItem('apiKey') || '';
    let modelName = localStorage.getItem('modelName') || 'gpt-3.5-turbo';
    let systemPrompt = localStorage.getItem('systemPrompt') || '你是一个友好的直播助手，负责回答观众的问题。请保持回答简洁、友好。';
    let autoReplyEnabled = localStorage.getItem('autoReplyEnabled') === 'true';
    
    // WebSocket连接
    let ws = null;
    
    // 自动回复状态
    let isProcessingReply = false;
    
    // 添加服务提供商切换逻辑
    let provider = localStorage.getItem('provider') || 'openai';
    let aliyunApiKey = localStorage.getItem('aliyunApiKey') || '';
    let aliyunAppId = localStorage.getItem('aliyunAppId') || '';
    
    // 初始化UI
    $('#server-url-input').val(serverUrl);
    $('#session-id-input').val(sessionId);
    $('#ws-url-input').val(wsUrl);
    $('#api-base-url').val(apiBaseUrl);
    $('#api-key').val(apiKey);
    $('#model-name').val(modelName);
    $('#system-prompt').val(systemPrompt);
    $('#auto-reply-toggle').prop('checked', autoReplyEnabled);
    $('#provider-select').val(provider);
    $('#aliyun-api-key').val(aliyunApiKey);
    $('#aliyun-app-id').val(aliyunAppId);
    
    // 根据选择的提供商显示对应的配置
    showProviderConfig(provider);
    
    updateAutoReplyStatus(autoReplyEnabled ? 'active' : 'inactive');
    
    // 初始化流类型
    const savedStreamType = localStorage.getItem('streamType') || 'webrtc';
    selectStreamType(savedStreamType);
    
    // 保存设置
    function saveSettings() {
        localStorage.setItem('serverUrl', serverUrl);
        localStorage.setItem('sessionId', sessionId);
        localStorage.setItem('wsUrl', wsUrl);
        localStorage.setItem('apiBaseUrl', apiBaseUrl);
        localStorage.setItem('apiKey', apiKey);
        localStorage.setItem('modelName', modelName);
        localStorage.setItem('systemPrompt', systemPrompt);
        localStorage.setItem('autoReplyEnabled', autoReplyEnabled);
        localStorage.setItem('provider', provider);
        localStorage.setItem('aliyunApiKey', aliyunApiKey);
        localStorage.setItem('aliyunAppId', aliyunAppId);
        localStorage.setItem('streamType', streamType);
    }
    
    // 自动保存设置
    $('#server-url-input').on('change', function() {
        serverUrl = $(this).val().trim();
        saveSettings();
    });
    
    $('#session-id-input').on('change', function() {
        sessionId = $(this).val().trim() || '0';
        saveSettings();
    });
    
    $('#ws-url-input').on('change', function() {
        wsUrl = $(this).val().trim();
        saveSettings();
    });
    
    $('#api-base-url').on('change', function() {
        apiBaseUrl = $(this).val().trim();
        saveSettings();
    });
    
    $('#api-key').on('change', function() {
        apiKey = $(this).val().trim();
        saveSettings();
    });
    
    $('#model-name').on('change', function() {
        modelName = $(this).val().trim();
        saveSettings();
    });
    
    $('#system-prompt').on('change', function() {
        systemPrompt = $(this).val().trim();
        saveSettings();
    });
    
    // 自动回复开关
    $('#auto-reply-toggle').on('change', function() {
        autoReplyEnabled = $(this).prop('checked');
        updateAutoReplyStatus(autoReplyEnabled ? 'active' : 'inactive');
        saveSettings();
    });
    
    // 监听提供商选择变化
    $('#provider-select').on('change', function() {
        provider = $(this).val();
        localStorage.setItem('provider', provider);
        showProviderConfig(provider);
        saveSettings();
    });
    
    // 监听阿里云配置变化
    $('#aliyun-api-key').on('change', function() {
        aliyunApiKey = $(this).val().trim();
        localStorage.setItem('aliyunApiKey', aliyunApiKey);
        saveSettings();
    });
    
    $('#aliyun-app-id').on('change', function() {
        aliyunAppId = $(this).val().trim();
        localStorage.setItem('aliyunAppId', aliyunAppId);
        saveSettings();
    });
    
    // 显示对应提供商的配置
    function showProviderConfig(provider) {
        if (provider === 'openai') {
            $('#openai-config').removeClass('hidden');
            $('#aliyun-config').addClass('hidden');
        } else if (provider === 'aliyun') {
            $('#openai-config').addClass('hidden');
            $('#aliyun-config').removeClass('hidden');
        }
    }
    
    // 更新自动回复状态
    function updateAutoReplyStatus(state, message) {
        const indicator = $('#auto-reply-indicator');
        const statusText = $('#auto-reply-status-text');
        const statusContainer = $('#auto-reply-status');
        
        indicator.removeClass('active inactive error processing');
        statusContainer.removeClass('active error processing');
        
        if (state === 'active') {
            indicator.addClass('active');
            statusContainer.addClass('active');
        } else if (state === 'error') {
            indicator.addClass('error');
            statusContainer.addClass('error');
        } else if (state === 'processing') {
            indicator.addClass('processing');
            statusContainer.addClass('processing');
        } else {
            indicator.addClass('inactive');
        }
        
        statusText.text(message);
    }
    
    // WebSocket连接
    $('#connect-ws-btn').click(function() {
        connectWebSocket();
    });
    
    $('#disconnect-ws-btn').click(function() {
        disconnectWebSocket();
    });
    
    function connectWebSocket() {
        wsUrl = $('#ws-url-input').val().trim();
        if (!wsUrl) {
            showStatus('error', '请输入WebSocket地址');
            return;
        }
        
        updateWsStatus('connecting');
        
        try {
            ws = new WebSocket(wsUrl);
            
            ws.onopen = function() {
                console.log('WebSocket连接已建立');
                updateWsStatus('connected');
                $('#connect-ws-btn').prop('disabled', true);
                $('#disconnect-ws-btn').prop('disabled', false);
                addSystemMessage('弹幕连接已建立');
            };
            
            ws.onmessage = function(event) {
                console.log('收到消息:', event.data);
                
                try {
                    // 解析外层JSON
                    const outerData = JSON.parse(event.data);
                    
                    // 检查是否有Type和Data字段
                    if (outerData.Type !== undefined && outerData.Data) {
                        // 解析内层JSON
                        const innerData = JSON.parse(outerData.Data);
                        
                        // 处理消息
                        processMessage(outerData.Type, innerData);
                    } else {
                        // 数据格式不符合预期，显示原始数据
                        addDanmakuMessage('未知格式', event.data, new Date());
                    }
                } catch (e) {
                    console.error('解析数据出错:', e);
                    addDanmakuMessage('解析错误', event.data, new Date());
                }
            };
            
            ws.onclose = function() {
                console.log('WebSocket连接已关闭');
                updateWsStatus('disconnected');
                $('#connect-ws-btn').prop('disabled', false);
                $('#disconnect-ws-btn').prop('disabled', true);
                addSystemMessage('弹幕连接已断开');
                ws = null;
            };
            
            ws.onerror = function(error) {
                console.error('WebSocket错误:', error);
                updateWsStatus('disconnected');
                $('#connect-ws-btn').prop('disabled', false);
                $('#disconnect-ws-btn').prop('disabled', true);
                addSystemMessage('弹幕连接出错');
            };
        } catch (error) {
            console.error('创建WebSocket连接失败:', error);
            updateWsStatus('disconnected');
            showStatus('error', '创建WebSocket连接失败: ' + error.message);
        }
    }
    
    function disconnectWebSocket() {
        if (ws) {
            ws.close();
        }
    }
    
    function updateWsStatus(status) {
        const indicator = $('#ws-indicator');
        const statusText = $('#ws-status-text');
        
        indicator.removeClass('connected disconnected connecting');
        
        if (status === 'connected') {
            indicator.addClass('connected');
            statusText.text('已连接');
        } else if (status === 'connecting') {
            indicator.addClass('connecting');
            statusText.text('连接中...');
        } else {
            indicator.addClass('disconnected');
            statusText.text('未连接');
        }
    }
    
    // 处理消息
    function processMessage(type, data) {
        // 提取内容
        const content = data.Content || '';
        
        // 如果内容为空，不处理
        if (!content) return;
        
        // 根据是否有User信息来决定显示方式
        if (data.User) {
            // 有用户信息，显示用户头像、名称和内容
            const user = data.User;
            const username = user.Nickname || '匿名用户';
            const avatar = user.HeadImgUrl || '';
            
            // 根据消息类型设置样式
            let messageType = 'normal';
            if (type === 3) messageType = 'enter'; // 进入直播间
            if (type === 4) messageType = 'follow'; // 关注主播
            
            addFormattedDanmakuMessage(username, content, avatar, messageType);
            
            // 如果自动回复已启用且不在处理中，则生成回复
            // 对所有类型的弹幕都进行处理
            if (autoReplyEnabled && !isProcessingReply) {
                console.log(`触发自动回复: ${username} 说 "${content}" (类型: ${type})`);
                generateAutoReply(username, content, type);
            }
        } else {
            // 没有用户信息，直接显示内容
            // 对于统计信息等系统消息，使用特殊样式
            let messageType = 'system';
            addSystemMessage(content, messageType);
            
            // 系统消息也可以触发自动回复
            if (autoReplyEnabled && !isProcessingReply) {
                console.log(`触发系统消息自动回复: "${content}" (类型: ${type})`);
                generateAutoReply('系统', content, type);
            }
        }
    }
    
    // 修改generateAutoReply函数，支持不同的服务提供商
    function generateAutoReply(username, content, messageType) {
        // 根据当前选择的提供商调用不同的API
        if (provider === 'openai') {
            generateOpenAIReply(username, content, messageType);
        } else if (provider === 'aliyun') {
            generateAliyunReply(username, content, messageType);
        }
    }
    
    // OpenAI兼容接口的回复生成
    function generateOpenAIReply(username, content, messageType) {
        if (!apiBaseUrl || !apiKey || !modelName) {
            updateAutoReplyStatus('error', 'OpenAI API配置不完整');
            return;
        }
        
        // 更新状态为处理中
        updateAutoReplyStatus('processing', '正在生成回复...');
        isProcessingReply = true;
        
        // 根据消息类型构建不同的提示
        let userPrompt = buildPromptByType(username, content, messageType);
        
        // 准备请求数据
        const requestData = {
            model: modelName,
            messages: [
                {
                    role: "system",
                    content: systemPrompt
                },
                {
                    role: "user",
                    content: userPrompt
                }
            ],
            temperature: 0.7,
            max_tokens: 150
        };
        
        // 发送请求到API
        fetch(`${apiBaseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${apiKey}`
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`API请求失败: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // 提取回复内容
            const reply = data.choices && data.choices[0] && data.choices[0].message ? 
                          data.choices[0].message.content.trim() : 
                          '无法生成回复';
            
            // 显示回复并发送到数字人
            handleModelReply(reply, messageType);
        })
        .catch(error => {
            console.error('自动回复出错:', error);
            updateAutoReplyStatus('error', `OpenAI回复出错: ${error.message}`);
        })
        .finally(() => {
            isProcessingReply = false;
        });
    }
    
    // 阿里云百炼的回复生成
    function generateAliyunReply(username, content, messageType) {
        if (!aliyunApiKey || !aliyunAppId) {
            updateAutoReplyStatus('error', '阿里云百炼配置不完整');
            return;
        }
        
        // 更新状态为处理中
        updateAutoReplyStatus('processing', '正在生成回复...');
        isProcessingReply = true;
        
        // 根据消息类型构建不同的提示
        let userPrompt = buildPromptByType(username, content, messageType);
        
        // 准备请求数据
        const requestData = {
            input: {
                prompt: userPrompt
            },
            parameters: {},
            debug: {}
        };
        
        // 发送请求到阿里云API
        fetch(`https://dashscope.aliyuncs.com/api/v1/apps/${aliyunAppId}/completion`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${aliyunApiKey}`
            },
            body: JSON.stringify(requestData)
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`阿里云API请求失败: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            // 提取回复内容
            const reply = data.output && data.output.text ? 
                          data.output.text.trim() : 
                          '无法生成回复';
            
            // 显示回复并发送到数字人
            handleModelReply(reply, messageType);
        })
        .catch(error => {
            console.error('阿里云自动回复出错:', error);
            updateAutoReplyStatus('error', `阿里云回复出错: ${error.message}`);
        })
        .finally(() => {
            isProcessingReply = false;
        });
    }
    
    // 根据消息类型构建提示词
    function buildPromptByType(username, content, messageType) {
        switch(messageType) {
            case 1: // 普通弹幕
                return `用户"${username}"说: ${content}`;
            case 3: // 进入直播间
                return `用户"${username}"进入了直播间: ${content}`;
            case 4: // 关注主播
                return `用户"${username}"关注了主播: ${content}`;
            case 6: // 直播间统计
                return `直播间统计信息: ${content}`;
            default:
                return `${username}: ${content} (消息类型: ${messageType})`;
        }
    }
    
    // 处理模型回复
    function handleModelReply(reply, messageType) {
        // 显示回复
        addReplyMessage(reply, messageType);
        
        // 发送回复到数字人
        if (serverUrl && sessionId) {
            sendToDigitalHuman(reply);
            updateAutoReplyStatus('active', '自动回复已发送到数字人');
        } else {
            updateAutoReplyStatus('error', '无法发送到数字人：未配置服务器地址或连接码');
        }
    }
    
    // 添加回复消息到界面
    function addReplyMessage(content, messageType) {
        const timeStr = new Date().toLocaleTimeString();
        
        // 根据消息类型设置不同的样式
        let replyClass = 'reply-message';
        let replyIcon = '';
        let replyLabel = 'AI助手';
        
        switch(messageType) {
            case 3: // 进入直播间回复
                replyClass += ' reply-enter';
                replyIcon = '<span class="reply-icon-enter"></span>';
                break;
            case 4: // 关注回复
                replyClass += ' reply-follow';
                replyIcon = '<span class="reply-icon-follow"></span>';
                break;
            case 6: // 统计信息回复
                replyClass += ' reply-system';
                replyIcon = '<span class="reply-icon-system"></span>';
                break;
        }
        
        // 创建回复消息HTML
        let replyItem = `
            <div class="danmaku-item ${replyClass}">
                <div class="danmaku-header">
                    ${replyIcon}
                    <span class="danmaku-user reply-user">${replyLabel}</span>
                    <span class="danmaku-time">${timeStr}</span>
                </div>
                <div class="danmaku-content">${content}</div>
            </div>
        `;
        
        const container = $('#danmaku-container');
        container.append(replyItem);
        container.scrollTop(container[0].scrollHeight);
    }
    
    // 修改sendToDigitalHuman函数，添加URL处理逻辑
    function sendToDigitalHuman(message) {
        // 获取当前服务器地址
        let currentUrl = $('#server-url-input').val().trim();
        let currentSessionId = $('#session-id-input').val().trim() || '0';
        
        // 确保服务器地址有效
        if (!currentUrl) {
            console.error('发送到数字人失败: 服务器地址未设置');
            updateAutoReplyStatus('error', '发送到数字人失败: 服务器地址未设置');
            return;
        }
        
        try {
            // 处理URL，与sendMessage函数中的逻辑相同
            let apiUrl;
            let requestBody;
            
            if (window.streamType === 'webrtc') {
                // WebRTC模式 - 使用原有逻辑
                let serverUrl = currentUrl;
                
                // 确保WebRTC模式下的URL也是以http或https开头
                if (serverUrl.startsWith('webrtc://')) {
                    // 如果是webrtc://开头，替换为http://
                    const server = serverUrl.replace('webrtc://', '').split('/')[0];
                    serverUrl = `http://${server}:8080`; // 添加默认端口8080
                    console.log('将WebRTC URL转换为HTTP:', serverUrl);
                } else if (!serverUrl.startsWith('http://') && !serverUrl.startsWith('https://')) {
                    // 如果不是以http或https开头，添加http://前缀
                    // 检查是否已经包含端口号
                    if (!serverUrl.includes(':')) {
                        serverUrl = 'http://' + serverUrl + ':8080'; // 添加默认端口8080
                    } else {
                        serverUrl = 'http://' + serverUrl;
                    }
                    console.log('添加HTTP前缀到URL:', serverUrl);
                } else if (serverUrl.startsWith('http://') && !serverUrl.includes(':', 7)) {
                    // 如果是http://开头但没有端口号，添加默认端口8080
                    serverUrl = serverUrl + ':8080';
                    console.log('添加默认端口到URL:', serverUrl);
                }
                
                apiUrl = serverUrl + '/human';
                console.log('自动回复WebRTC模式URL:', apiUrl);
                console.log('连接码: ', currentSessionId);
                
                requestBody = {
                    text: message,
                    type: 'echo',
                    interrupt: true,
                    sessionid: parseInt(currentSessionId),
                };
            } else {
                // SRS流模式 - 转换URL格式
                // 从webrtc://server/app/stream转换为http://server:8010
                let serverUrl = currentUrl;
                let httpUrl = serverUrl;
                
                // 检查URL是否以webrtc://开头，如果是则提取服务器地址
                if (serverUrl.startsWith('webrtc://')) {
                    // 提取服务器地址部分
                    const server = serverUrl.replace('webrtc://', '').split('/')[0];
                    httpUrl = `http://${server}:8010`;
                    console.log('转换SRS URL:', serverUrl, '->', httpUrl);
                } else if (!serverUrl.startsWith('http://') && !serverUrl.startsWith('https://')) {
                    // 如果不是以http或https开头，假设是服务器地址，添加http://前缀和:8010端口
                    httpUrl = `http://${serverUrl}:8010`;
                    console.log('添加HTTP前缀:', serverUrl, '->', httpUrl);
                }
                
                apiUrl = httpUrl + '/human';
                console.log('自动回复SRS模式URL: ', apiUrl);
                
                // SRS模式不需要sessionid
                requestBody = {
                    text: message,
                    type: 'echo',
                    interrupt: true
                };
            }
            
            console.log(`发送到数字人: ${message}`);
            
            fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(requestBody)
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error(`发送失败: ${response.status}`);
                }
                console.log('成功发送到数字人');
            })
            .catch(error => {
                console.error('发送到数字人出错:', error);
                updateAutoReplyStatus('error', `发送到数字人出错: ${error.message}`);
            });
        } catch (error) {
            console.error('URL处理错误:', error);
            updateAutoReplyStatus('error', `URL处理错误: ${error.message}`);
        }
    }
    
    // 添加系统消息
    function addSystemMessage(content, type = 'system') {
        const timeStr = new Date().toLocaleTimeString();
        
        // 创建系统消息HTML
        let danmakuItem = `
            <div class="danmaku-item ${type}">
                <div class="danmaku-header">
                    <span class="danmaku-system-icon"></span>
                    <span class="danmaku-system-label">系统消息</span>
                    <span class="danmaku-time">${timeStr}</span>
                </div>
                <div class="danmaku-content">${content}</div>
            </div>
        `;
        
        const container = $('#danmaku-container');
        container.append(danmakuItem);
        container.scrollTop(container[0].scrollHeight);
    }
    
    // 添加格式化的弹幕消息
    function addFormattedDanmakuMessage(username, content, avatar, type = 'normal') {
        const timeStr = new Date().toLocaleTimeString();
        
        // 创建弹幕项HTML
        let danmakuItem = `
            <div class="danmaku-item ${type}">
                <div class="danmaku-header">
                    ${avatar ? `<img src="${avatar}" class="danmaku-avatar" alt="${username}">` : ''}
                    <span class="danmaku-user">${username}</span>
                    <span class="danmaku-time">${timeStr}</span>
                </div>
                <div class="danmaku-content">${content}</div>
            </div>
        `;
        
        const container = $('#danmaku-container');
        container.append(danmakuItem);
        container.scrollTop(container[0].scrollHeight);
    }
    
    // 添加普通弹幕消息
    function addDanmakuMessage(user, content, time) {
        const timeStr = time.toLocaleTimeString();
        const danmakuItem = `
            <div class="danmaku-item">
                <span class="danmaku-user">${user}</span>
                <span class="danmaku-time">${timeStr}</span>
                <div class="danmaku-content">${content}</div>
            </div>
        `;
        
        const container = $('#danmaku-container');
        container.append(danmakuItem);
        container.scrollTop(container[0].scrollHeight);
    }
    
    // 修改发送消息函数
    function sendMessage() {
        // 更新输入值
        const inputUrl = $('#server-url-input').val().trim();
        sessionId = $('#session-id-input').val().trim() || '0';
        
        // 根据当前模式保存不同的URL
        if (window.streamType === 'webrtc') {
            localStorage.setItem('webrtcServerUrl', inputUrl);
        } else {
            localStorage.setItem('srsServerUrl', inputUrl);
        }
        
        // 保存其他设置
        localStorage.setItem('sessionId', sessionId);
        localStorage.setItem('wsUrl', $('#ws-url-input').val().trim());
        
        const message = $('#message').val();
        if (!message) {
            return;
        }
        
        if (!inputUrl) {
            showStatus('error', '请先输入服务器地址');
            return;
        }
        
        console.log('发送: ' + message);
        
        try {
            // 根据流类型处理URL
            let apiUrl;
            let requestBody;
            
            if (window.streamType === 'webrtc') {
                // WebRTC模式 - 使用原有逻辑
                let serverUrl = inputUrl;
                
                // 确保WebRTC模式下的URL也是以http或https开头
                if (serverUrl.startsWith('webrtc://')) {
                    // 如果是webrtc://开头，替换为http://
                    const server = serverUrl.replace('webrtc://', '').split('/')[0];
                    serverUrl = `http://${server}:8080`; // 添加默认端口8080
                    console.log('将WebRTC URL转换为HTTP:', serverUrl);
                } else if (!serverUrl.startsWith('http://') && !serverUrl.startsWith('https://')) {
                    // 如果不是以http或https开头，添加http://前缀
                    // 检查是否已经包含端口号
                    if (!serverUrl.includes(':')) {
                        serverUrl = 'http://' + serverUrl + ':8080'; // 添加默认端口8080
                    } else {
                        serverUrl = 'http://' + serverUrl;
                    }
                    console.log('添加HTTP前缀到URL:', serverUrl);
                } else if (serverUrl.startsWith('http://') && !serverUrl.includes(':', 7)) {
                    // 如果是http://开头但没有端口号，添加默认端口8080
                    serverUrl = serverUrl + ':8080';
                    console.log('添加默认端口到URL:', serverUrl);
                }
                
                apiUrl = serverUrl + '/human';
                console.log('WebRTC模式URL:', apiUrl);
                console.log('连接码: ', sessionId);
                
                requestBody = {
                    text: message,
                    type: 'echo',
                    interrupt: true,
                    sessionid: parseInt(sessionId),
                };
            } else {
                // SRS流模式 - 转换URL格式
                // 从webrtc://server/app/stream转换为http://server:8010
                let serverUrl = inputUrl;
                let httpUrl = serverUrl;
                
                // 检查URL是否以webrtc://开头，如果是则提取服务器地址
                if (serverUrl.startsWith('webrtc://')) {
                    // 提取服务器地址部分
                    const server = serverUrl.replace('webrtc://', '').split('/')[0];
                    httpUrl = `http://${server}:8010`;
                    console.log('转换SRS URL:', serverUrl, '->', httpUrl);
                } else if (!serverUrl.startsWith('http://') && !serverUrl.startsWith('https://')) {
                    // 如果不是以http或https开头，假设是服务器地址，添加http://前缀和:8010端口
                    httpUrl = `http://${serverUrl}:8010`;
                    console.log('添加HTTP前缀:', serverUrl, '->', httpUrl);
                }
                
                apiUrl = httpUrl + '/human';
                console.log('SRS模式URL: ', apiUrl);
                
                // SRS模式不需要sessionid
                requestBody = {
                    text: message,
                    type: 'echo',
                    interrupt: true
                };
            }
            
            // 显示发送状态
            $('#send-btn').prop('disabled', true).text('发送中...');
            
            fetch(apiUrl, {
                body: JSON.stringify(requestBody),
                headers: {
                    'Content-Type': 'application/json'
                },
                method: 'POST'
            }).then(response => {
                $('#send-btn').prop('disabled', false).text('发送');
                
                if (response.ok) {
                    $('#message').val('');
                    showStatus('success', '发送成功');
                } else {
                    showStatus('error', '发送失败: ' + response.status);
                }
            }).catch(error => {
                $('#send-btn').prop('disabled', false).text('发送');
                showStatus('error', '发送错误: ' + error.message);
                console.error('请求错误:', error);
            });
        } catch (error) {
            // 捕获URL处理过程中的错误
            $('#send-btn').prop('disabled', false).text('发送');
            showStatus('error', '发送错误: ' + error.message);
            console.error('URL处理错误:', error);
        }
    }
    
    // 替换原有的sendMessage函数
    window.sendMessage = sendMessage;
    $('#send-btn').off('click').on('click', sendMessage);
    
    function showStatus(type, message) {
        const statusEl = $('#send-status');
        const iconEl = $('#status-icon');
        const textEl = $('#status-text');
        
        iconEl.removeClass('success error').addClass(type);
        textEl.text(message);
        statusEl.addClass('visible');
        
        setTimeout(() => {
            statusEl.removeClass('visible');
        }, 3000);
    }
    
    // 添加键盘快捷键
    $('#message').keydown(function(e) {
        if (e.ctrlKey && e.keyCode === 13) {
            sendMessage();
            return false;
        }
    });
    
    // 尝试自动连接WebSocket
    if (wsUrl) {
        setTimeout(connectWebSocket, 1000);
    }
});
</script>
</body>
</html> 